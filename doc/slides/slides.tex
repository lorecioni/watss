\documentclass{beamer}
\usepackage{xcolor}
\usepackage{mathtools}
\usetheme[titlepagelogo=firenze,% Logo for the first page
		  language=italian,
		  bullet=circle,
		  color=blue,
         ]{TorinoTh}
\usepackage[beamer,customcolors]{hf-tikz}
\usepackage[noend]{algpseudocode}
\usepackage[Algoritmo]{algorithm}
\renewcommand{\thealgorithm}{}
\definecolor{UniBlue}{RGB}{83,121,170}
\uselanguage{italian}
\languagepath{italian}
\deftranslation[to=italian]{Definition}{Definizione}
\deftranslation[to=italian]{Theorem}{Teorema}
\setbeamercolor{block title}{use=structure,fg=white,bg=UniBlue}
\setbeamercolor{block body}{use=structure,fg=black,bg=white}
\usepackage{proof}

\newcommand*{\bfrac}[2]{\genfrac{}{}{0pt}{1}{#1}{#2}}

\author{}
\rel{{\normalsize \emph{Teoria dei Linguaggi di Programmazione}}\\\vspace{0.3cm}Lorenzo Cioni}
\title{\huge Type reconstruction}
\date{20 Aprile 2015}

\begin{document}

\titlepageframe

% ------ Variabili di tipo -------- %

\begin{tframe}{Variabili di tipo}

Scegliamo un sistema di tipi contenente un insieme di tipi primitivi ed i tipi freccia
$$T = T_p \cup T_f$$
con
$$T_p = \{Bool, Nat, \ldots \} \qquad T_f = \{X_1 \rightarrow X_2 : X_1, X_2 \in T_p \cup T_f \}$$
\vspace{0.1cm}

A partire da questo sistema di tipi così definito definiamo le \textbf{variabili di tipo} come \emph{placeholders}, ovvero variabili di cui non conosciamo il tipo specifico, ma che utilizziamo all'interno dei termini.
\end{tframe}

% ------ Polimorfismo parametrico -------- %

\begin{tframe}{Polimorfismo parametrico}

Le variabili di tipo introducono il concetto di \textbf{polimorfismo parametrico}, dove le stesse variabili possono essere usate in contesti diversi con differenti tipi concreti.

\vspace{0.4cm}

Durante la fase di \emph{type checking} non sarà dunque necessario effettuare la sostituzione della variabile con un tipo concreto, ma verificheremo che il termine sia \emph{ben tipabile} a prescindere dalla sostituzione stessa.
\end{tframe}


% ------ Tipo principale -------- %

\begin{tframe}{Type reconstruction}
Scopo della \emph{type reconstruction} è inferire istanze valide per le variabili di tipo di un termine, lasciando al programmatore la libertà di specificare o meno i tipi.

\vspace{0.4cm}

Siamo interessati ad inferire il \textbf{tipo principale} di un termine, ovvero:

\vspace{0.1cm}

\begin{enumerate}
\item Che contiene variabili (\emph{schema di tipo})
\item Il più generale che rappresenta tutti i possibili tipi (\emph{polimorfismo parametrico})
\end{enumerate}
\end{tframe}

% ------ Sostituzioni -------- %

\begin{tframe}{Sostituzioni di tipo}

Le variabili di tipo possono essere \emph{sostituite}:

\vspace{0.2cm}

\begin{definition}[{Sostituzione di tipo}]
\textit{Una \emph{sostituzione di tipo} è una \textbf{funzione $\sigma$} che associa variabili di tipo a tipi. L'insieme delle variabili che compaiono a sinistra delle coppie in $\sigma$ è detto \textbf{dom($\sigma$)}; l'insieme delle variabili che compaiono a destra delle coppie in $\sigma$ è detto \textbf{range($\sigma$)}}.
\end{definition}
\vspace{0.2cm}

L'applicazione di una sostituzione di tipo avviene applicando ciascuna clausola contemporaneamente.

\vspace{0.5cm}

\textit{Esempio:} $\sigma = [X \mapsto Nat, \; Y \mapsto X]$
\emph{sostituisce la variabile di tipo $X$ con il tipo primitivo $Nat$ e la variabile $Y$ con la variabile $X$}.
\end{tframe}

% ------ Applicazione-------- %

\begin{tframe}{Applicazione di sostituzione di tipo}

L'\textbf{applicazione} di una sostituzione a un tipo è definita come:

$$\sigma(X) = \left\{
\begin{array}{ll}
 T & \mbox{se } (X \mapsto T) \in \sigma \\
 X & \mbox{se } X \not\in dom(\sigma)
\end{array}
\right.$$
$$\sigma(Nat) = Nat$$
$$\sigma(Bool) = Bool$$
$$\sigma(T_1 \rightarrow T_2) = \sigma(T_1) \rightarrow \sigma(T_2)$$

\vspace{0.3cm}
La sostituzione di tipo è estesa al \textbf{contesto} definendo:

$$\sigma(x_1: T_1, \ldots, x_n:T_n) = (x_1:\sigma(T_1), \ldots, x_n:\sigma(T_n))$$
\end{tframe}

% ------ Preservazione dei tipi con le sostituzioni -------- %

\begin{tframe}{Preservazione di tipo}

Una proprietà importante delle sostituzioni di tipo è che mantengono la \textbf{\emph{tipabilità}}: se al termine assegno un tipo con variabili, allora tutte le istanze delle sue sostituzioni di tipo sono tipi corretti per il termine.

\vspace{0.8cm}

\begin{theorem}[Preservazione di tipo con sostituzioni]
\textit{Se $\sigma$ è una sostituzione di tipo e $\Gamma \vdash t:T$, allora $\sigma \Gamma \vdash \sigma t : \sigma T$}
\end{theorem}
\end{tframe}

% ------ Algoritmo di type reconstruction -------- %

\begin{tframe}{Algoritmo di type reconstruction}

L'algoritmo di \emph{type reconstruction}, dunque, a partire da un termine $t$ in un contesto $\Gamma$, permette di generare la \emph{sostituzione più generale} che tipa correttamente il termine.

\vspace{0.2cm}

Il procedimento è suddiviso in due fasi consecutive:
\vspace{0.4cm}
\begin{enumerate}
\item \emph{\textbf{Costraint-based typing}}: in questa prima fase, prima vengono assegnate delle variabili di tipo ai termini, poi vengono generati dei vincoli logici dipendenti dal contesto su tali variabili;
\item \emph{\textbf{Unification}}: a partire dai vincoli generati al passo precedente, viene cercata la sostituzione più generale in grado di unificarli tutti.
\end{enumerate}
\end{tframe}

% ------ Tipaggio basato su vincoli -------- %

\begin{tframe}{Tipaggio basato su vincoli}

\begin{definition}[Soluzione]
\textit{Sia $\Gamma$ un contesto e $t$ un termine. Una \textbf{soluzione} per $(\Gamma, t)$ è una coppia $(\sigma, T)$ tale che $\sigma T \vdash \sigma t : T$}
\end{definition}

\vspace{0.2cm}

\vspace{0.2cm}

\begin{definition}[Insieme di vincoli]
\textit{Un \textbf{insieme di vincoli} $C$ è un insieme di equazioni $\{ S_i = T_{i}^{i \in 1, \ldots, n} \}$. Una sostituzione $\sigma$ \textbf{unifica} (o \textbf{soddisfa}) un'equazione $S = T$ se $\sigma S = \sigma T$. La sostituzione unifica $C$ se unifica tutte le equazioni in $C$}
\end{definition}
\end{tframe}

% ------ Regole -------- %

\begin{tframe}{Regole - I}
\setbeamercovered{transparent}

\begin{itemize}

\item<1->[]
  \begin{equation}
    \frac{\Gamma, x : T_1 \; \vdash \; t_2 : T_2  \quad |_\mathcal{X} \quad C}{\Gamma \; \vdash \; \lambda x : T_1. \; \; t_2 : T_1 \rightarrow T_2 \quad |_\mathcal{X} \quad C}\tag{CT-ABS}
  \end{equation}
  \vspace{0.05cm}
\item<2->[]
  \begin{equation} 
    \frac{\bfrac{\bfrac{\Gamma \; \vdash \; t_1 : T_1 \quad |_{\mathcal{X}_1} \quad C_1 \qquad \Gamma \; \vdash \; t_2 : T_2 \quad |_{\mathcal{X}_2} \quad C_2 \vspace{0.01cm}}{\mathcal{X}_1 \; \cap \; \mathcal{X}_2 = \mathcal{X}_1 \; \cap \; FV(T_2) = \mathcal{X}_2 \; \cap \; FV(T_1) = \varnothing  \vspace{0.01cm}} }{\bfrac{X \; \not \in \; \mathcal{X}_1, \mathcal{X}_2, T_1, T_2, C_1, C_2, \Gamma, t_1, t_2  \vspace{0.01cm}}{C' = C_1 \; \cup \; C_2 \; \cup \; \{T_1 = T_2 \rightarrow X \}  \vspace{0.1cm}}}}{\Gamma \vdash t_1 t_2 : X \quad |_{\mathcal{X}_1 \; \cup \; \mathcal{X}_2 \; \cup \; X} \quad C'}\tag{CT-APP}
  \end{equation}
    \vspace{0.05cm}
  \item<3->[]
  \begin{equation}
    \frac{\bfrac{\Gamma \; \vdash \; t_1 : T \quad |_{\mathcal{X}} \quad C}{C' = C  \; \cup \; \{ T = Nat \}}}{\Gamma \; \vdash \; succ \; t_1 : Nat \quad |_\mathcal{X} \quad C'}\tag{CT-SUCC}
  \end{equation}  
\end{itemize}
\end{tframe}

\begin{tframe}{Regole - II}
\setbeamercovered{transparent}

\begin{itemize}

\item<1->[]
  \begin{equation}
    \frac{\bfrac{\Gamma \; \vdash \; t_1 : T \quad |_{\mathcal{X}} \quad C}{C' = C \; \cup  \;\{ T = Nat \}}}{\Gamma \; \vdash \; iszero \; t_1 : Bool \quad |_\mathcal{X} \quad C'}\tag{CT-ISZERO}
  \end{equation}
  \vspace{0.05cm}
\item<2->[]
  \begin{equation}
    \frac{\bfrac{\bfrac{\Gamma \; \vdash \; t_1 : T_1 \quad |_{\mathcal{X}_1} \quad C_1}{\Gamma \; \vdash \; t_2 : T_2 \quad |_{\mathcal{X}_2} \quad C_2 \qquad  \Gamma \; \vdash \; t_3 : T_3 \quad |_{\mathcal{X}_3} \quad C_3} }{\bfrac{\mathcal{X}_1 \; \cap \; \mathcal{X}_2 \; \cap \; \mathcal{X}_3 \; = \; \varnothing}{C' = C_1 \; \cup \; C_2 \; \cup \; C_3 \; \cup \; \{T_1 = Bool, T_2 = T_3\}  \vspace{0.1cm}}}}{\Gamma \; \vdash \; if \; t_1 \; then \; t_2 \; else \; t_3 : T_2 \quad |_{\mathcal{X}_1 \; \cup \; \mathcal{X}_2 \; \cup \; \mathcal{X}_3 } \quad C'}\tag{CT-IF}
  \end{equation}
\end{itemize}
\end{tframe}

% ------ Osservazioni sulle regole -------- %

\begin{tframe}{Osservazioni sulle regole}
\begin{itemize}
\item Quando viene introdotta una nuova variabile di tipo, questa deve essere \textbf{fresca}, \emph{fresh}, cioè diversa da qualsiasi altra variabile utilizzata.
\vspace{0.3cm}
\item Quando una regola coinvolge due o più sottoderivazioni, i due insiemi di variabili devono essere \emph{disgiunti}.
\end{itemize}
\vspace{0.3cm}
Le regole così definite permettono \textbf{sempre} di costruire una derivazione per un termine (con variabili di tipo): dato un termine $t$ ed un contesto $\Gamma$ è \emph{sempre} possibile determinare $T$ ed un insieme di vincoli $C$ tali che:
$$\Gamma \; \vdash \; t : T \quad | \; C$$
Il termine sarà però \textbf{tipabile} solo se $\exists$ una sostituzione $\sigma$ che unifica l'insieme di vincoli.
\end{tframe}

% ------ Esempio I -------- %

\begin{tframe}{Esempio - I}
\emph{Esempio di applicazione a } $\lambda x.\; \lambda y. \; \; x \; y $
\end{tframe}

\begin{tframe}{Esempio - I}
\emph{Esempio di applicazione a } $\lambda x.\; \lambda y. \; \; x \; y \quad \Rightarrow \quad \lambda x : X.\; \lambda y : Y. \; \; x \; y$
\begin{itemize}
\item<1->[]
\item<2->[]
\vspace{-0.6cm}
\begin{displaymath}
\infer{\lambda x : X.\; \lambda y : Y. \; \; x \; y \; : \; X \rightarrow W \quad | \quad \{ W = Y \rightarrow Z,\; X = Y \rightarrow Z \} }{x : X \; \vdash & \infer{\lambda y : Y. \; x \; y \; : W \quad | \quad \{ W = Y \rightarrow Z\} \cup \{X = Y \rightarrow Z \}}{y : Y \; \vdash & \infer{x \; y : Z \quad | \quad \{ X = Y \rightarrow Z \}}{x : X & y : Y & \{ X = Y \rightarrow Z \}}}}
\end{displaymath}
\item<3->[]\vspace{0.8cm}\textbf{\emph{Soluzione}}: \textbf{$\sigma$} $= [W \mapsto (Y \rightarrow Z), \; X \mapsto (Y \rightarrow Z)]$
\end{itemize}
\end{tframe}

% ------ Tipo principale -------- %

\begin{tframe}{Tipo principale}
\begin{definition}[]
\textit{Sia $\Gamma \vdash t : S | C$. Una soluzione per $(\Gamma, t, S, C)$ è una coppia $(\sigma, T)$ tale che $\sigma$ unifica $C$ e $\sigma S = T$}
\end{definition}

\vspace{0.3cm}

Tra tutte le soluzioni al problema $(\Gamma, t, S, C)$ vogliamo quella più generale possibile, ovvero vogliamo ricavare il \emph{tipo principale}:

\vspace{0.3cm}

\begin{definition}[Tipo principale]
\textit{La \textbf{soluzione principale} di $(\Gamma, t, S, C)$ è la soluzione $(\sigma, T)$ tale che per ogni $(\sigma', T')$ soluzione di $(\Gamma, t, S, C)$ abbiamo che $\sigma \sqsubseteq \sigma'$. Definiamo dunque $T$ il \textbf{tipo principale} di $t$ in $\Gamma$}
\end{definition}
\end{tframe}

% ------ Correttezza e completezza -------- %

\begin{tframe}{Correttezza e completezza}
\emph{Correttezza}: ogni soluzione di $(\Gamma, t, S, C)$ è anche soluzione di $(\Gamma, T)$.

\vspace{0.1cm}

\begin{theorem}[Correttezza del tipaggio basato su vincoli]
\textit{Sia $\Gamma \vdash t : S | C$. Se $(\sigma, T)$ è una soluzione per $(\Gamma , t, S, C)$, cioè $\sigma$ soddisfa $C$ e $\sigma S = T$, allora lo è anche per $(\Gamma, t)$}
\end{theorem}

\vspace{0.1cm}

\emph{Completezza}: ogni soluzione $(\Gamma, T)$ può essere estesa ad una soluzione per $(\Gamma, t, S, C)$.

\vspace{0.1cm}


\begin{theorem}[Completezza del tipaggio basato su vincoli]
\textit{Supponiamo $\Gamma \vdash t : S |_{\mathcal{X}} C$. Se $(\sigma, T)$ è una soluzione per $(\Gamma, t)$ e $dom(\sigma) \; \cap \; \mathcal{X} = \varnothing$, allora esiste una soluzione $(\sigma', T)$ per $(\Gamma, t, S, C)$ tale che $\sigma' / \mathcal{X} = \sigma$, con $\sigma' / \mathcal{X}$ indicata la sostituzione non definita per le variabili in $\mathcal{X}$}
\end{theorem}
\end{tframe}

% ------ Unificazione -------- %

\begin{tframe}{Unificazione}
Per il calcolo della soluzione, dato l'insieme di vincoli sulle variabili di tipo, viene utilizzato l'\textbf{algoritmo di unificazione} (\textit{Robinson, 1971}). L'algoritmo verifica se l'insieme delle soluzioni è \emph{non vuoto} e restituisce la soluzione più \emph{generale}.

\vspace{0.6cm}

L'algoritmo, per come è definito, previene la generazione di soluzioni che includono \emph{sostituzioni cicliche} (ad esempio $X \mapsto X \rightarrow X$), che non hanno senso in espressioni finite.

\end{tframe}

% ------ Unificazione - Algoritmo-------- %

\begin{tframe}{Unificazione}
\begin{algorithm}[H]
\scriptsize
\begin{algorithmic}[20]
\vspace{0.3cm}
 \Function{unify}{$C$}
	\If {$C = \varnothing$} []
	\Else
		\State Let $\{ S = T \} \cup C' = C$
		\If {$S = T$}
			\State $unify(C')$
		\ElsIf {$S = X \mbox{ and } X \not \in FV(T)$ }
			\State $unify([X \mapsto T] C') \circ [X \mapsto T]$
		\ElsIf {$T = X \mbox{ and } X \not \in FV(S)$ }
			\State $unify([X \mapsto S] C') \circ [X \mapsto S]$
		\ElsIf {$S = S_1 \rightarrow S_2 \mbox{ and } T = T_1 \rightarrow T_2$}
			\State $unify(C' \cup \{ S_1 = T_1, S_2 = T_2 \})$
		\Else
			\State $fail$
		\EndIf
  	\EndIf
  \EndFunction
  \vspace{0.3cm}
\end{algorithmic}
\caption{Unificazione di Robinson}
\label{alg:seq}
\end{algorithm}
\end{tframe}

% ------ Unificazione - Completezza -------- %

\begin{tframe}{Correttezza e completezza}
L'algoritmo \textbf{unify} termina sempre, fallisce quando l'insieme di vincoli dato non è unificabile mentre ritorna l'\textbf{unificatore principale} nel caso in cui esista almeno un unificatore.

\vspace{0.3cm}

\begin{theorem}[Completezza dell'algoritmo di unificazione]
\textit{\begin{enumerate}
\vspace{-0.2cm}
\item \emph{unify($C$)} termina sempre, fallendo oppure restituendo una sostituzione che unifica l'insieme di vincoli $C$;
\item Se \emph{unify($C$) = $\sigma$}, allora $\sigma$ unifica l'insieme di vincoli $C$;
\item Se $\delta$ unifica $C$, allora \emph{unify($C$) = $\sigma$} con $\sigma \sqsubseteq \delta$.
\end{enumerate}}
\end{theorem}
\end{tframe}

% ------ Esempio II -------- %

\begin{tframe}{Esempio - II}
\emph{Esempio di applicazione a } $\lambda x.\; x \; x$
\end{tframe}

\begin{tframe}{Esempio - II}
\emph{Esempio di applicazione a } $\lambda x.\; x \; x \quad \Rightarrow \quad \lambda x : X.\; x \; x $
\begin{itemize}
\item<1->[]
\item<2->[]
\begin{displaymath}
\infer{\lambda x : X. \; x \; x : X \rightarrow W \quad | \quad \{ X = X \rightarrow W \}}{x : X \; \vdash & \infer{x \; x : W \quad | \quad \{X = X \rightarrow W \}}{x : X & x : X & \{X = X \rightarrow W\}}}
\end{displaymath}
\item<2->[] \vspace{0.8cm}\emph{Nessuna sostituzione finita possibile $\Rightarrow$ \textbf{fallimento}}
\end{itemize}
\end{tframe}

% ------ Considerazioni -------- %

\begin{tframe}{Considerazioni}
L'esempio precedente non è tipabile con tipi \textbf{finiti} a causa della ricorsione di tipo: l'algoritmo di unificazione \emph{fallisce}.

Questo a causa dei due controlli effettuati, $X \not \in FV(T)$ e $X \not \in FV(S)$, chiamati \emph{occur check} che impediscono la generazione di espressioni di tipo finite. Questi due controlli vengono rimossi in condizioni particolari quali i \textbf{tipi ricorsivi}, ad esempio della forma $X \rightarrow (X \rightarrow X)$.

\vspace{0.5cm}

Altri casi di fallimento:
\begin{itemize}
\item Vincoli su tipi primitivi irrisolvibili. \emph{Esempio: $Bool = Nat$}
\item Presenza di vincoli di uguaglianza tra tipi primitivi e tipi freccia. \emph{Esempio: $Nat = X \rightarrow Bool$}
\end{itemize}
\end{tframe}


\end{document}